package com.bcm.messenger.common.database.migrate

import com.bcm.messenger.common.AccountContext
import com.bcm.messenger.common.crypto.MasterCipher
import com.bcm.messenger.common.crypto.MasterSecret
import com.bcm.messenger.common.database.db.MigrateDatabase
import com.bcm.messenger.common.preferences.TextSecurePreferences
import com.bcm.messenger.common.crypto.encrypt.BCMEncryptUtils
import com.bcm.messenger.common.database.repositories.Repository
import com.bcm.messenger.common.deprecated.*
import com.bcm.messenger.common.grouprepository.room.dao.*
import com.bcm.messenger.common.utils.isReleaseBuild
import com.bcm.messenger.utility.AppContextHolder
import com.bcm.messenger.utility.logger.ALog
import com.commonsware.cwac.saferoom.SQLCipherUtils
import io.reactivex.Observable
import io.reactivex.android.schedulers.AndroidSchedulers
import io.reactivex.schedulers.Schedulers

/**
 * Database migration processor.
 *
 * First create an origin database without encryption.
 * Then move all data to the new database.
 * Close all databases and encrypt the new database after moving all data.
 * Last open the new database using room with an empty migration to make the data correct.
 *
 * DO NOT EDIT THIS FILE IF FUNCTIONS WORK NORMALLY!!
 *
 * Created by Kin on 2019/9/27
 */
object DatabaseMigration : IDatabaseMigration {
    private val TAG = "DatabaseMigration"
    private val threadIdMap = hashMapOf<Long, Long>()

    private var isUpgrading = false

    override fun doMigrate(accountContext: AccountContext, callback: (finishCount: Int) -> Unit) {
        val migrateDatabase = MigrateDatabase(accountContext)
        val masterSecret = BCMEncryptUtils.getMasterSecret(accountContext)
        val oldDatabase = DatabaseFactory(accountContext, AppContextHolder.APP_CONTEXT)
        if (masterSecret != null && !isUpgrading) {
            isUpgrading = true
            Observable.create<Int> {
                ALog.i(TAG, "Start migrate")
                ALog.i(TAG, "Clear new db tables")
//                UserDatabase.getDatabase().clearAllTables()
                migrateDatabase.clearTables()
                it.onNext(0)

                ALog.i(TAG, "Start migrate threads")
                doMigrateThreads(oldDatabase.thread, migrateDatabase, masterSecret)
                it.onNext(1)

                ALog.i(TAG, "Start migrate drafts")
                doMigrateDrafts(oldDatabase.draftDatabase, migrateDatabase, masterSecret)
                it.onNext(2)

                ALog.i(TAG, "Start migrate push")
                doMigratePush(oldDatabase.pushDatabase, migrateDatabase)
                it.onNext(3)

                ALog.i(TAG, "Start migrate private messages")
                doMigrateMessages(oldDatabase.mmsSmsDatabase, oldDatabase, migrateDatabase, masterSecret)
                it.onNext(4)

                ALog.i(TAG, "Start migrate identity key")
                doMigrateIdentityKey(oldDatabase.identityDatabase, migrateDatabase)
                it.onNext(5)

                ALog.i(TAG, "Start migrate recipient")
                doMigrateRecipient(oldDatabase.recipientDatabase, oldDatabase.identityDatabase, migrateDatabase)
                it.onNext(6)

                ALog.i(TAG, "Start migrate adhoc channel info")
                doMigrateAdHocChannelInfo(oldDatabase.newGroupDatabase.adHocChannelDao(), migrateDatabase)
                it.onNext(7)

                ALog.i(TAG, "Start migrate adhoc messages")
                doMigrateAdHocMessage(oldDatabase.newGroupDatabase.adHocMessageDao(), migrateDatabase)
                it.onNext(8)

                ALog.i(TAG, "Start migrate adhoc session info")
                doMigrateSessionInfo(oldDatabase.newGroupDatabase.adHocSessionDao(), migrateDatabase)
                it.onNext(9)

                ALog.i(TAG, "Start migrate bcm friend")
                doMigrateBcmFriend(oldDatabase.newGroupDatabase.bcmFriendDao(), migrateDatabase)
                it.onNext(10)

                ALog.i(TAG, "Start migrate friend request")
                doMigrateBcmFriendRequest(oldDatabase.newGroupDatabase.friendRequestDao(), migrateDatabase)
                it.onNext(11)

                ALog.i(TAG, "Start migrate hide messages")
                doMigrateChatHideMessage(oldDatabase.newGroupDatabase.chatControlMessageDao(), migrateDatabase)
                it.onNext(12)

                ALog.i(TAG, "Start migrate avatar param")
                doMigrateGroupAvatarParam(oldDatabase.newGroupDatabase.groupAvatarParamsDao(), migrateDatabase)
                it.onNext(13)

                ALog.i(TAG, "Start migrate group info")
                doMigrateGroupInfo(oldDatabase.newGroupDatabase.groupInfo(), migrateDatabase)
                it.onNext(14)

                ALog.i(TAG, "Start migrate group join request")
                doMigrateGroupJoinRequest(oldDatabase.newGroupDatabase.groupJoinInfoDao(), migrateDatabase)
                it.onNext(15)

                ALog.i(TAG, "Start migrate live info")
                doMigrateLiveInfo(oldDatabase.newGroupDatabase.groupLiveInfo(), migrateDatabase)
                it.onNext(16)

                ALog.i(TAG, "Start migrate group member")
                doMigrateGroupMember(oldDatabase.newGroupDatabase.groupMemberDao(), migrateDatabase)
                it.onNext(17)

                ALog.i(TAG, "Start migrate group message")
                doMigrateGroupMessage(oldDatabase.newGroupDatabase.GroupMessage(), migrateDatabase)
                it.onNext(18)

                ALog.i(TAG, "Start migrate note record")
                doMigrateNoteRecord(oldDatabase.newGroupDatabase.noteRecordDao(), migrateDatabase)
                it.onNext(19)

                ALog.i(TAG, "Start migrate group key")
                doMigrateGroupKey(oldDatabase.newGroupDatabase.groupKeyDao(), migrateDatabase)
                it.onNext(20)

                // ，
                ALog.i(TAG, "Migrate success, clear old db tables")
//                DatabaseFactory.getInstance(AppContextHolder.APP_CONTEXT).deleteAllDatabase()
//                GroupDatabase.getInstance().clearAllTables()
                it.onNext(21)

                ALog.i(TAG, "Close all database to encrypt")
                doEncryptDatabase(accountContext, oldDatabase, migrateDatabase, masterSecret)
                it.onNext(22)

                ALog.i(TAG, "Migrate completed")
                it.onComplete()
            }.subscribeOn(Schedulers.io())
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe({
                        callback(it)
                    }, {
                        // ，，
                        ALog.e(TAG, "Migrate failed", it)
//                        UserDatabase.getDatabase().clearAllTables()
                        val returnCode = doMigrateFailed(accountContext, migrateDatabase)
                        isUpgrading = false
                        callback(returnCode)
                    })
        } else {
            ALog.e(TAG, "MasterSecret is null!!")
            val returnCode = doMigrateFailed(accountContext, migrateDatabase)
            callback(returnCode)
        }
    }

    private fun doMigrateThreads(threadDatabase: ThreadDatabase, migrateDatabase: MigrateDatabase, masterSecret: MasterSecret) {
        val cursor = threadDatabase.conversationList
        val reader = threadDatabase.readerFor(cursor, MasterCipher(masterSecret))
        while (reader.nextForMigrate != null) {
            val oldRecord = reader.currentForMigrate

            val id = migrateDatabase.insertThread(oldRecord, threadDatabase)
            threadIdMap[oldRecord.threadId] = id
        }
    }

    private fun doMigrateDrafts(draftDatabase: DraftDatabase, migrateDatabase: MigrateDatabase, masterSecret: MasterSecret) {
        val masterCipher = MasterCipher(masterSecret)

        threadIdMap.keys.forEach {
            val drafts = draftDatabase.getDrafts(masterCipher, it)
            val newId = threadIdMap[it] ?: throw RuntimeException("Cannot found new thread ID")
            drafts.forEach { oldDraft ->
                migrateDatabase.insertDraft(newId, oldDraft)
            }
        }
    }

    private fun doMigratePush(pushDatabase: PushDatabase, migrateDatabase: MigrateDatabase) {
        val cursor = pushDatabase.pending
        val reader = pushDatabase.readerFor(cursor)
        var pair = reader.nextEnvelop
        do {
            if (pair != null) {
                migrateDatabase.insertPush(pair)
            }
            pair = reader.nextEnvelop
        } while (pair != null)
    }

    private fun doMigrateMessages(mmsSmsDatabase: MmsSmsDatabase, databaseFactory: DatabaseFactory, migrateDatabase: MigrateDatabase, masterSecret: MasterSecret) {
        threadIdMap.keys.forEach {
            val newId = threadIdMap[it] ?: throw RuntimeException("Cannot found new thread ID")
            val cursor = mmsSmsDatabase.getConversationAsc(it)
            val reader = mmsSmsDatabase.readerFor(cursor, masterSecret)
            while (reader.getNextMigrate(databaseFactory) != null) {
                val oldRecord = reader.getCurrentMigrate(databaseFactory)

                migrateDatabase.insertMessageAndAttachment(newId, oldRecord)
            }
        }
    }

    private fun doMigrateIdentityKey(identityDatabase: IdentityDatabase, migrateDatabase: MigrateDatabase) {
        val cursor = identityDatabase.identities
        val reader = identityDatabase.readerFor(cursor)
        var identityKey = reader?.next
        do {
            if (identityKey != null) {
                migrateDatabase.insertIdentity(identityKey)

                identityKey = reader?.next
            }
        } while (identityKey != null)
    }

    private fun doMigrateRecipient(recipientDatabase: RecipientDatabase, identityDatabase: IdentityDatabase, migrateDatabase: MigrateDatabase) {
        val cursor = recipientDatabase.allDatabaseRecipients
        while (cursor?.moveToNext() == true) {
            val oldSettings = RecipientDatabase.getRecipientSettings(cursor, identityDatabase) ?: continue

            migrateDatabase.insertRecipient(oldSettings)
        }
    }

    private fun doMigrateAdHocChannelInfo(oldDao: AdHocChannelDao, migrateDatabase: MigrateDatabase) {
        oldDao.loadAllChannel().forEach {
            migrateDatabase.insertAdHocChannel(it)
        }
    }

    private fun doMigrateAdHocMessage(oldDao: AdHocMessageDao, migrateDatabase: MigrateDatabase) {
        var page = 0
        while (true) {
            val messageList = oldDao.loadByPage(page * 100)
            messageList.forEach {
                migrateDatabase.insertAdHocMessage(it)
            }

            if (messageList.isEmpty() || messageList.size < 100) break
            page++
        }
    }

    private fun doMigrateSessionInfo(oldDao: AdHocSessionDao, migrateDatabase: MigrateDatabase) {
        oldDao.loadAllSession().forEach {
            migrateDatabase.insertSessionInfo(it)
        }
    }

    private fun doMigrateBcmFriend(oldDao: BcmFriendDao, migrateDatabase: MigrateDatabase) {
        oldDao.queryAll().forEach {
            migrateDatabase.insertBcmFriend(it)
        }
    }

    private fun doMigrateBcmFriendRequest(oldDao: FriendRequestDao, migrateDatabase: MigrateDatabase) {
        oldDao.queryAll().forEach {
            migrateDatabase.insertBcmFriendRequest(it)
        }
    }

    private fun doMigrateChatHideMessage(oldDao: ChatHideMessageDao, migrateDatabase: MigrateDatabase) {
        var page = 0
        while (true) {
            val messageList = oldDao.queryByPage(page * 100)
            messageList.forEach {
                migrateDatabase.insertHideMessage(it)
            }

            if (messageList.isEmpty() || messageList.size < 100) break
            page++
        }
    }

    private fun doMigrateGroupAvatarParam(oldDao: GroupAvatarParamsDao, migrateDatabase: MigrateDatabase) {
        var page = 0
        while (true) {
            val paramsList = oldDao.queryByPage(page * 100)
            paramsList.forEach {
                migrateDatabase.insertGroupAvatarParams(it)
            }

            if (paramsList.isEmpty() || paramsList.size < 100) break
            page++
        }
    }

    private fun doMigrateGroupInfo(oldDao: GroupInfoDao, migrateDatabase: MigrateDatabase) {
        oldDao.loadAll().forEach {
            migrateDatabase.insertGroupInfo(it)
        }
    }

    private fun doMigrateGroupJoinRequest(oldDao: GroupJoinInfoDao, migrateDatabase: MigrateDatabase) {
        var page = 0
        while (true) {
            val joinInfoList = oldDao.queryByPage(page * 100)
            joinInfoList.forEach {
                migrateDatabase.insertGroupRequest(it)
            }

            if (joinInfoList.isEmpty() || joinInfoList.size < 100) break
            page++
        }
    }

    private fun doMigrateLiveInfo(oldDao: GroupLiveInfoDao, migrateDatabase: MigrateDatabase) {
        var page = 0
        while (true) {
            val liveInfoList = oldDao.queryByPage(page * 100)
            liveInfoList.forEach {
                migrateDatabase.insertGroupLiveInfo(it)
            }

            if (liveInfoList.isEmpty() || liveInfoList.size < 100) break
            page++
        }
    }

    private fun doMigrateGroupMember(oldDao: GroupMemberDao, migrateDatabase: MigrateDatabase) {
        var page = 0
        while (true) {
            val memberList = oldDao.queryGroupMemberByPage(page * 500)
            memberList.forEach {
                migrateDatabase.insertGroupMember(it)
            }

            if (memberList.isEmpty() || memberList.size < 500) break
            page++
        }
    }

    private fun doMigrateGroupMessage(oldDao: GroupMessageDao, migrateDatabase: MigrateDatabase) {
        var page = 0
        while (true) {
            val messageList = oldDao.loadMessageByPage(page * 500)
            messageList.forEach {
                migrateDatabase.insertGroupMessage(it)
            }

            if (messageList.isEmpty() || messageList.size < 500) break
            page++
        }
    }

    private fun doMigrateNoteRecord(oldDao: NoteRecordDao, migrateDatabase: MigrateDatabase) {
        oldDao.queryNoteList().forEach {
            migrateDatabase.insertNoteRecord(it)
        }
    }

    private fun doMigrateGroupKey(oldDao: GroupKeyDao, migrateDatabase: MigrateDatabase) {
        oldDao.queryKeys().forEach {
            migrateDatabase.insertGroupKey(it)
        }
    }

    private fun doEncryptDatabase(accountContext: AccountContext, oldDatabase: DatabaseFactory, migrateDatabase: MigrateDatabase, masterSecret: MasterSecret) {
        migrateDatabase.closeDatabase()
        oldDatabase.close()

        // Do encryption if version is release build.
        if (isReleaseBuild()) {
            SQLCipherUtils.encrypt(AppContextHolder.APP_CONTEXT, "user_${accountContext.uid}.db", masterSecret.encryptionKey.encoded)
        }

        Repository.getInstance(accountContext)
    }

    private fun doMigrateFailed(accountContext: AccountContext, migrateDatabase: MigrateDatabase): Int {
        migrateDatabase.deleteDatabase()

        // Set failed count
        var migrateFailedCount = TextSecurePreferences.getMigrateFailedCount(accountContext)
        if (migrateFailedCount < 3) {
            migrateFailedCount++
        }
        TextSecurePreferences.setMigrateFailedCount(accountContext, migrateFailedCount)

        return if (migrateFailedCount == 3) -2 else -1
//        return -2
    }

    override fun clearFlag() {
        isUpgrading = false
    }
}