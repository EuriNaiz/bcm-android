package com.bcm.messenger.common.database.migrate

import com.bcm.messenger.common.AccountContext
import com.bcm.messenger.common.crypto.MasterCipher
import com.bcm.messenger.common.crypto.MasterSecret
import com.bcm.messenger.common.database.DatabaseFactory
import com.bcm.messenger.common.database.RecipientDatabase
import com.bcm.messenger.common.database.db.MigrateDatabase
import com.bcm.messenger.common.grouprepository.room.database.GroupDatabase
import com.bcm.messenger.common.preferences.TextSecurePreferences
import com.bcm.messenger.common.crypto.encrypt.BCMEncryptUtils
import com.bcm.messenger.common.database.repositories.Repository
import com.bcm.messenger.common.utils.isReleaseBuild
import com.bcm.messenger.utility.AppContextHolder
import com.bcm.messenger.utility.logger.ALog
import com.commonsware.cwac.saferoom.SQLCipherUtils
import io.reactivex.Observable
import io.reactivex.android.schedulers.AndroidSchedulers
import io.reactivex.schedulers.Schedulers

/**
 * Database migration processor.
 *
 * First create an origin database without encryption.
 * Then move all data to the new database.
 * Close all databases and encrypt the new database after moving all data.
 * Last open the new database using room with an empty migration to make the data correct.
 *
 * DO NOT EDIT THIS FILE IF FUNCTIONS WORK NORMALLY!!
 *
 * Created by Kin on 2019/9/27
 */
object DatabaseMigration : IDatabaseMigration {
    private val TAG = "DatabaseMigration"
    private val threadIdMap = hashMapOf<Long, Long>()

    private var isUpgrading = false

    override fun doMigrate(accountContext: AccountContext, callback: (finishCount: Int) -> Unit) {
        val migrateDatabase = MigrateDatabase(accountContext)
        val masterSecret = BCMEncryptUtils.getMasterSecret(accountContext)
        if (masterSecret != null && !isUpgrading) {
            isUpgrading = true
            Observable.create<Int> {
                ALog.i(TAG, "Start migrate")
                ALog.i(TAG, "Clear new db tables")
//                UserDatabase.getDatabase().clearAllTables()
                migrateDatabase.clearTables()
                it.onNext(0)

                ALog.i(TAG, "Start migrate threads")
                doMigrateThreads(migrateDatabase, masterSecret)
                it.onNext(1)

                ALog.i(TAG, "Start migrate drafts")
                doMigrateDrafts(migrateDatabase, masterSecret)
                it.onNext(2)

                ALog.i(TAG, "Start migrate push")
                doMigratePush(migrateDatabase)
                it.onNext(3)

                ALog.i(TAG, "Start migrate private messages")
                doMigrateMessages(migrateDatabase, masterSecret)
                it.onNext(4)

                ALog.i(TAG, "Start migrate identity key")
                doMigrateIdentityKey(migrateDatabase)
                it.onNext(5)

                ALog.i(TAG, "Start migrate recipient")
                doMigrateRecipient(migrateDatabase)
                it.onNext(6)

                ALog.i(TAG, "Start migrate adhoc channel info")
                doMigrateAdHocChannelInfo(migrateDatabase)
                it.onNext(7)

                ALog.i(TAG, "Start migrate adhoc messages")
                doMigrateAdHocMessage(migrateDatabase)
                it.onNext(8)

                ALog.i(TAG, "Start migrate adhoc session info")
                doMigrateSessionInfo(migrateDatabase)
                it.onNext(9)

                ALog.i(TAG, "Start migrate bcm friend")
                doMigrateBcmFriend(migrateDatabase)
                it.onNext(10)

                ALog.i(TAG, "Start migrate friend request")
                doMigrateBcmFriendRequest(migrateDatabase)
                it.onNext(11)

                ALog.i(TAG, "Start migrate hide messages")
                doMigrateChatHideMessage(migrateDatabase)
                it.onNext(12)

                ALog.i(TAG, "Start migrate avatar param")
                doMigrateGroupAvatarParam(migrateDatabase)
                it.onNext(13)

                ALog.i(TAG, "Start migrate group info")
                doMigrateGroupInfo(migrateDatabase)
                it.onNext(14)

                ALog.i(TAG, "Start migrate group join request")
                doMigrateGroupJoinRequest(migrateDatabase)
                it.onNext(15)

                ALog.i(TAG, "Start migrate live info")
                doMigrateLiveInfo(migrateDatabase)
                it.onNext(16)

                ALog.i(TAG, "Start migrate group member")
                doMigrateGroupMember(migrateDatabase)
                it.onNext(17)

                ALog.i(TAG, "Start migrate group message")
                doMigrateGroupMessage(migrateDatabase)
                it.onNext(18)

                ALog.i(TAG, "Start migrate note record")
                doMigrateNoteRecord(migrateDatabase)
                it.onNext(19)

                ALog.i(TAG, "Start migrate group key")
                doMigrateGroupKey(migrateDatabase)
                it.onNext(20)

                // ，
                ALog.i(TAG, "Migrate success, clear old db tables")
//                DatabaseFactory.getInstance(AppContextHolder.APP_CONTEXT).deleteAllDatabase()
//                GroupDatabase.getInstance().clearAllTables()
                it.onNext(21)

                ALog.i(TAG, "Close all database to encrypt")
                doEncryptDatabase(accountContext, migrateDatabase, masterSecret)
                it.onNext(22)

                ALog.i(TAG, "Migrate completed")
                it.onComplete()
            }.subscribeOn(Schedulers.io())
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe({
                        callback(it)
                    }, {
                        // ，，
                        ALog.e(TAG, "Migrate failed", it)
//                        UserDatabase.getDatabase().clearAllTables()
                        val returnCode = doMigrateFailed(accountContext, migrateDatabase)
                        isUpgrading = false
                        callback(returnCode)
                    })
        } else {
            ALog.e(TAG, "MasterSecret is null!!")
            val returnCode = doMigrateFailed(accountContext, migrateDatabase)
            callback(returnCode)
        }
    }

    private fun doMigrateThreads(migrateDatabase: MigrateDatabase, masterSecret: MasterSecret) {
        val threadDatabase = DatabaseFactory.getThreadDatabase(AppContextHolder.APP_CONTEXT)

        val cursor = threadDatabase.conversationList
        val reader = threadDatabase.readerFor(cursor, MasterCipher(masterSecret))
        while (reader.nextForMigrate != null) {
            val oldRecord = reader.currentForMigrate

            val id = migrateDatabase.insertThread(oldRecord)
            threadIdMap[oldRecord.threadId] = id
        }
    }

    private fun doMigrateDrafts(migrateDatabase: MigrateDatabase, masterSecret: MasterSecret) {
        val draftDatabase = DatabaseFactory.getDraftDatabase(AppContextHolder.APP_CONTEXT)
        val masterCipher = MasterCipher(masterSecret)

        threadIdMap.keys.forEach {
            val drafts = draftDatabase.getDrafts(masterCipher, it)
            val newId = threadIdMap[it] ?: throw RuntimeException("Cannot found new thread ID")
            drafts.forEach { oldDraft ->
                migrateDatabase.insertDraft(newId, oldDraft)
            }
        }
    }

    private fun doMigratePush(migrateDatabase: MigrateDatabase) {
        val pushDatabase = DatabaseFactory.getPushDatabase(AppContextHolder.APP_CONTEXT)

        val cursor = pushDatabase.pending
        val reader = pushDatabase.readerFor(cursor)
        var pair = reader.nextEnvelop
        do {
            if (pair != null) {
                migrateDatabase.insertPush(pair)
            }
            pair = reader.nextEnvelop
        } while (pair != null)
    }

    private fun doMigrateMessages(migrateDatabase: MigrateDatabase, masterSecret: MasterSecret) {
        val mmsSmsDatabase = DatabaseFactory.getMmsSmsDatabase(AppContextHolder.APP_CONTEXT)

        threadIdMap.keys.forEach {
            val newId = threadIdMap[it] ?: throw RuntimeException("Cannot found new thread ID")
            val cursor = mmsSmsDatabase.getConversationAsc(it)
            val reader = mmsSmsDatabase.readerFor(cursor, masterSecret)
            while (reader.nextMigrate != null) {
                val oldRecord = reader.currentMigrate

                migrateDatabase.insertMessageAndAttachment(newId, oldRecord)
            }
        }
    }

    private fun doMigrateIdentityKey(migrateDatabase: MigrateDatabase) {
        val identityDatabase = DatabaseFactory.getIdentityDatabase(AppContextHolder.APP_CONTEXT)

        val cursor = identityDatabase.identities
        val reader = identityDatabase.readerFor(cursor)
        var identityKey = reader?.next
        do {
            if (identityKey != null) {
                migrateDatabase.insertIdentity(identityKey)

                identityKey = reader?.next
            }
        } while (identityKey != null)
    }

    private fun doMigrateRecipient(migrateDatabase: MigrateDatabase) {
        val recipientDatabase = DatabaseFactory.getRecipientDatabase(AppContextHolder.APP_CONTEXT)
                ?: throw RuntimeException("Recipient database is NULL !!")

        val cursor = recipientDatabase.allDatabaseRecipients
        while (cursor?.moveToNext() == true) {
            val oldSettings = RecipientDatabase.getRecipientSettings(cursor) ?: continue

            migrateDatabase.insertRecipient(oldSettings)
        }
    }

    private fun doMigrateAdHocChannelInfo(migrateDatabase: MigrateDatabase) {
        val oldDao = GroupDatabase.getInstance().adHocChannelDao()
        oldDao.loadAllChannel().forEach {
            migrateDatabase.insertAdHocChannel(it)
        }
    }

    private fun doMigrateAdHocMessage(migrateDatabase: MigrateDatabase) {
        val oldDao = GroupDatabase.getInstance().adHocMessageDao()

        var page = 0
        while (true) {
            val messageList = oldDao.loadByPage(page * 100)
            messageList.forEach {
                migrateDatabase.insertAdHocMessage(it)
            }

            if (messageList.isEmpty() || messageList.size < 100) break
            page++
        }
    }

    private fun doMigrateSessionInfo(migrateDatabase: MigrateDatabase) {
        val oldDao = GroupDatabase.getInstance().adHocSessionDao()

        oldDao.loadAllSession().forEach {
            migrateDatabase.insertSessionInfo(it)
        }
    }

    private fun doMigrateBcmFriend(migrateDatabase: MigrateDatabase) {
        val oldDao = GroupDatabase.getInstance().bcmFriendDao()

        oldDao.queryAll().forEach {
            migrateDatabase.insertBcmFriend(it)
        }
    }

    private fun doMigrateBcmFriendRequest(migrateDatabase: MigrateDatabase) {
        val oldDao = GroupDatabase.getInstance().friendRequestDao()

        oldDao.queryAll().forEach {
            migrateDatabase.insertBcmFriendRequest(it)
        }
    }

    private fun doMigrateChatHideMessage(migrateDatabase: MigrateDatabase) {
        val oldDao = GroupDatabase.getInstance().chatControlMessageDao()

        var page = 0
        while (true) {
            val messageList = oldDao.queryByPage(page * 100)
            messageList.forEach {
                migrateDatabase.insertHideMessage(it)
            }

            if (messageList.isEmpty() || messageList.size < 100) break
            page++
        }
    }

    private fun doMigrateGroupAvatarParam(migrateDatabase: MigrateDatabase) {
        val oldDao = GroupDatabase.getInstance().groupAvatarParamsDao()

        var page = 0
        while (true) {
            val paramsList = oldDao.queryByPage(page * 100)
            paramsList.forEach {
                migrateDatabase.insertGroupAvatarParams(it)
            }

            if (paramsList.isEmpty() || paramsList.size < 100) break
            page++
        }
    }

    private fun doMigrateGroupInfo(migrateDatabase: MigrateDatabase) {
        val oldDao = GroupDatabase.getInstance().groupInfo()

        oldDao.loadAll().forEach {
            migrateDatabase.insertGroupInfo(it)
        }
    }

    private fun doMigrateGroupJoinRequest(migrateDatabase: MigrateDatabase) {
        val oldDao = GroupDatabase.getInstance().groupJoinInfoDao()

        var page = 0
        while (true) {
            val joinInfoList = oldDao.queryByPage(page * 100)
            joinInfoList.forEach {
                migrateDatabase.insertGroupRequest(it)
            }

            if (joinInfoList.isEmpty() || joinInfoList.size < 100) break
            page++
        }
    }

    private fun doMigrateLiveInfo(migrateDatabase: MigrateDatabase) {
        val oldDao = GroupDatabase.getInstance().groupLiveInfo()

        var page = 0
        while (true) {
            val liveInfoList = oldDao.queryByPage(page * 100)
            liveInfoList.forEach {
                migrateDatabase.insertGroupLiveInfo(it)
            }

            if (liveInfoList.isEmpty() || liveInfoList.size < 100) break
            page++
        }
    }

    private fun doMigrateGroupMember(migrateDatabase: MigrateDatabase) {
        val oldDao = GroupDatabase.getInstance().groupMemberDao()

        var page = 0
        while (true) {
            val memberList = oldDao.queryGroupMemberByPage(page * 500)
            memberList.forEach {
                migrateDatabase.insertGroupMember(it)
            }

            if (memberList.isEmpty() || memberList.size < 500) break
            page++
        }
    }

    private fun doMigrateGroupMessage(migrateDatabase: MigrateDatabase) {
        val oldDao = GroupDatabase.getInstance().GroupMessage()

        var page = 0
        while (true) {
            val messageList = oldDao.loadMessageByPage(page * 500)
            messageList.forEach {
                migrateDatabase.insertGroupMessage(it)
            }

            if (messageList.isEmpty() || messageList.size < 500) break
            page++
        }
    }

    private fun doMigrateNoteRecord(migrateDatabase: MigrateDatabase) {
        val oldDao = GroupDatabase.getInstance().noteRecordDao()

        oldDao.queryNoteList().forEach {
            migrateDatabase.insertNoteRecord(it)
        }
    }

    private fun doMigrateGroupKey(migrateDatabase: MigrateDatabase) {
        val oldDao = GroupDatabase.getInstance().groupKeyDao()

        oldDao.queryKeys().forEach {
            migrateDatabase.insertGroupKey(it)
        }
    }

    private fun doEncryptDatabase(accountContext: AccountContext, migrateDatabase: MigrateDatabase, masterSecret: MasterSecret) {
        migrateDatabase.closeDatabase()

        // Do encryption if version is release build.
        if (isReleaseBuild()) {
            SQLCipherUtils.encrypt(AppContextHolder.APP_CONTEXT, "user_${accountContext.uid}.db", masterSecret.encryptionKey.encoded)
        }

        Repository.getInstance(accountContext)
    }

    private fun doMigrateFailed(accountContext: AccountContext, migrateDatabase: MigrateDatabase): Int {
        migrateDatabase.deleteDatabase()

        // Set failed count
        var migrateFailedCount = TextSecurePreferences.getMigrateFailedCount(accountContext)
        if (migrateFailedCount < 3) {
            migrateFailedCount++
        }
        TextSecurePreferences.setMigrateFailedCount(accountContext, migrateFailedCount)

        return if (migrateFailedCount == 3) -2 else -1
//        return -2
    }

    override fun clearFlag() {
        isUpgrading = false
    }
}